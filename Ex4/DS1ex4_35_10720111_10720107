// 10720111 陳少暉 10720107 陳丕中

#include<iostream>
#include<cstdio>
#include<vector>
#include<string>
#include<ctime>

using namespace std ;

struct Job {

    // 每個工作所帶有的資料
    int ID ;
    int arrival ;
    int duration ;
    int timeout ;

};

struct DoneJob {

    int ID ;
    int out ;
    int delay ;

};

class sortQueue {

    struct QueueNode {
		Job aJob ;
		QueueNode * next ;
	};

	QueueNode * backPtr ;
	QueueNode * frontPtr ;
	int length ;

	public :

    sortQueue() {
        frontPtr = NULL ;
        backPtr = NULL ;
        length = 0 ;
    } // sortqueue
    ~sortQueue() {
        while( !IsEmpty() )
            DeQueue() ;
    } // ~sortqueue

	bool IsEmpty() ;
	void EnQueue( Job newJob ) ;
	void DeQueue() ;
	void DeQueue( Job &aJob ) ;
	void GetFront( Job &aJob ) ;
	void GetBack( Job &aJob ) ;
    int Length() ;

};

bool sortQueue::IsEmpty() {

	if ( frontPtr == NULL )
	    return true ;
	else if ( backPtr == NULL )
	    return true ;
    else
        return false ;
} // isEmpty()

void sortQueue::EnQueue ( Job newJob ) { // enQueue() 新增
   // 將東西放入queue
	QueueNode * newPtr = new QueueNode ;
	newPtr->aJob = newJob ;
	newPtr->next = NULL ;

	if ( IsEmpty() )
	    frontPtr = newPtr ;
	else
	    backPtr->next = newPtr ;

    backPtr = newPtr ;
    length++ ;
} // enQueue()

void sortQueue::DeQueue () { // deQueue 移除
    // 將東西拿出queue

	if ( IsEmpty() ) {
		printf( "is Empty!") ;
	} // if
	else {
	    QueueNode * tempPtr = frontPtr ;
	    if ( frontPtr == backPtr ) {
	    	frontPtr = NULL ;
	    	backPtr = NULL ;
	    } // if
	    else {
	    	frontPtr = frontPtr->next ;
	    } // else

	    tempPtr->next = NULL ;
    	delete tempPtr ;
    	length--;
    } // else

} //deQueue()

void sortQueue::GetFront ( Job &aJob ) { // getFront() 擷取
    // 看queue最前面是什麼

	if ( IsEmpty() )
	    printf("is Empty!!") ;

    else
        aJob = frontPtr->aJob ;

} // getFront()

void sortQueue::GetBack( Job &aJob ) {
    if ( IsEmpty() )
        cout << "There is nothing.\n" ;
    else
        aJob = backPtr->aJob ;
} // GetBack

void sortQueue::DeQueue( Job &aJob ) { // deQueue() 擷取後刪除
    if( IsEmpty() ) {
    	printf("is Empty!") ;
	} // if
	else {
		aJob = frontPtr->aJob ;
		DeQueue() ;
	} // else

} // 擷取後刪除

int sortQueue::Length() {
    return length ;
} // Length


class JobList {
    // 存放工作的清單

    vector<Job> aList ;

    public:

    void Sort( clock_t &t ) ;
    bool Load( string fileName, clock_t &t ) ;
    bool Load( string fileName ) ;
    void PrintAll() ;
    bool Export( string fileName, clock_t &t ) ;
    Job At( int i ) ;
    int Size() ;

}; // class JobList

int JobList::Size() {
    return aList.size() ;
} // Size

Job JobList::At( int i ) {
    return aList.at( i ) ;
} // At

bool JobList::Export( string fileName, clock_t &t ) {
    // Export sorted job list to .txt

    t = clock() ;
    FILE *outFile = NULL ;
    bool success = false ;
    fileName = "sorted" + fileName + ".txt" ;
    outFile = fopen( fileName.c_str(), "w" ) ;
    if ( outFile == NULL )
        ;
    else {

        fprintf( outFile, "OID\tArrival\tDuration\tTimeOut\n" ) ;
        for ( int i = 0 ; i < aList.size() ; i++ ) {
            fprintf( outFile, "%d\t%d\t%d\t%d\n", aList.at( i ).ID, aList.at( i ).arrival
                    , aList.at( i ).duration, aList.at( i ).timeout ) ;
        } // for

        success = true ;
        fclose( outFile ) ;

    } // else

    t = clock() - t ;
    return success ;

} // Export

void JobList::PrintAll(){

    cout << "OID\tArrival\tDuration\tTimeOut\n" ;
    for ( int i = 0 ; i < aList.size() ; i++ ) {
        cout << aList.at(i).ID << "\t" << aList.at(i).arrival << "\t" ;
        cout << aList.at(i).duration << "\t" << aList.at(i).timeout << "\n" ;
    } // for
    cout << "\n" ;

} // PrintAll

void JobList::Sort( clock_t &t ){
    // 用shell sort將其變為從小到大排序
    t = clock() ;
    for ( int gap = aList.size()/2 ; gap > 0 ; gap = gap / 2 )
        for ( int i = gap ; i < aList.size() ; i++ ) {
            Job tempJob = aList.at( i ) ;
            int j = -1 ;
            for ( j = i ; j >= gap && ( tempJob.arrival < aList.at( j - gap ).arrival
                || ( tempJob.arrival == aList.at( j - gap ).arrival
                    && tempJob.ID < aList.at( j - gap ).ID ) ) ; j = j - gap ) {
                aList.at( j ) = aList.at( j -  gap ) ;
            } // for

            aList.at(j) = tempJob ;
        } // for
    t = clock() - t ;

} // Sort

bool JobList::Load( string fileName, clock_t &t ) {
    // 讀檔
    FILE *infile = NULL ;
    bool success = false ;
    t = clock() ;

    fileName = "input" + fileName + ".txt" ;
    infile = fopen(fileName.c_str(), "r" ) ;

	if ( infile == NULL )
		;
	else{

        char temp ;

        while ( fscanf( infile, "%c", &temp ) != EOF && temp != '\n' )
            ;

        Job aJob ;
        while ( fscanf( infile, "%d %d %d %d", &aJob.ID, &aJob.arrival, &aJob.duration, &aJob.timeout ) != EOF )
            aList.push_back( aJob ) ;

        success = true ;
        fclose( infile ) ;

	} // else

    t = clock() - t ;

	return success ;

} // Load

bool JobList::Load( string fileName ) {
    // 讀檔
    FILE *infile = NULL ;
    bool success = false ;

    fileName = "sorted" + fileName + ".txt" ;
    infile = fopen(fileName.c_str(), "r" ) ;

	if ( infile == NULL )
		;
	else{

        char temp ;

        while ( fscanf( infile, "%c", &temp ) != EOF && temp != '\n' )
            ;

        Job aJob ;
        while ( fscanf( infile, "%d %d %d %d", &aJob.ID, &aJob.arrival, &aJob.duration, &aJob.timeout ) != EOF )
            aList.push_back( aJob ) ;

        success = true ;
        fclose( infile ) ;

	} // else

	return success ;

} // Load


struct DepartureEvent {
    int ID ;
    int Departure ;
};

struct Event {
    char type ;
    Job aEvent ;
    DepartureEvent dEvent ;
};

class EventList {

    vector<Event> eventList ;

    public:

    void PutEventIn( Event newEvent );
    bool IsEmpty() ;
    Event Pop() ;

}; // class EventList

void EventList::PutEventIn( Event newEvent ) {

    if ( IsEmpty() )
        eventList.push_back( newEvent ) ;
    else if ( newEvent.type == 'a' && newEvent.aEvent.arrival < eventList.at( 0 ).dEvent.Departure )
        eventList.insert( 0, newEvent ) ; //insert infront of it
    else if ( newEvent.type == 'd' && newEvent.dEvent.Departure <= eventList.at( 0 ).aEvent.arrival )
        eventList.insert( 0, newEvent ) ; // front insert
    else
        eventList.push_back( newEvent ) ;

} // Put

bool EventList::IsEmpty() {
    return eventList.empty() ;
} // Empty

class Simulation {

    JobList jobList ;
    sortQueue aQueue ;
    EventList eventList ;
    vector<DoneJob> abortList ;
    vector<DoneJob> doneList ;

    public:

    void Simulate() ;
    void ProccessArrival( Event newEvent ) ;
    void ProccessDeparture( Event newEvent ) ;
    bool LoadJobList( string fileName ) ;

};

bool Simulation::LoadJobList( string fileName ) {
    return jobList.Load( fileName ) ;
} // Load

void Simulation::ProccessArrival( Event newEvent ) {
    if ( aQueue.IsEmpty() ) {
        // just run?
        aQueue.EnQueue( newEvent );
    } // if
    else if ( aQueue.Length() == 3 ) {
        // abort it?
        DoneJob abortJob ;
        abortJob.ID = ;
    } // else if
    else
    // put it into the queue?
        ;
} // ProccessArrival

void Simulation::ProccessDeparture( Event newEvent ) {
    Job tempJob ;
    aQueue.GetBack( tempJob ) ;
    if ( !aQueue.IsEmpty() && tempJob < )
        ;

} // Proccess Departure

void Simulation::Simulate() {

    Event AEvent ;
    AEvent.type = 'a' ;
    AEvent.aEvent = jobList.At( 0 ) ;
    eventList.PutEventIn( AEvent ) ;
    while ( !eventList.IsEmpty() ) {
        Event newEvent = eventList.Pop() ;
        if ( newEvent.type == 'a' )
            ProccessArrival( newEvent ) ;
        else
            ProccessDeparture( newEvent ) ;
    } // while

} // Simulate

int main(){

    cout << "(0)Exit\n(1)Sort file\n(2)Simulate(not yet)\n" ;
    cout << "Command: " ;
    int cmd = -1 ;
    cin >> cmd ;
    while ( cmd != 0 ) {
        if ( cmd == 1 ) {

            JobList aList ;
            string fileName ;
            cout << "file name:" ;
            cin >> fileName ;
            clock_t tLoad, tSort, tExport ;
            if ( !aList.Load( fileName, tLoad ) )
                cout << "Can not find the file.\n" ;
            else {
                aList.PrintAll() ;
                aList.Sort( tSort ) ;
                aList.Export( fileName, tExport ) ;
                float msLoad = (float)tLoad / CLOCKS_PER_SEC * 1000 ,
                      msSort = (float)tSort / CLOCKS_PER_SEC * 1000 ,
                      msExport = (float)tExport / CLOCKS_PER_SEC * 1000  ;

                printf( "Reading data: %d clocks (%.2f ms).\n", tLoad, msLoad ) ;
                printf( "Sorting data: %d clocks (%.2f ms).\n", tSort, msSort ) ;
                printf( "Writing data: %d clocks (%.2f ms).\n", tExport, msExport ) ;

                aList.PrintAll() ;
            } // else

        } // if
        else if( cmd == 2 ) {

            Simulation aSimulation ;
            string fileName ;
            cout << "file name:" ;
            cin >> fileName ;
            aSimulation.LoadJobList( fileName ) ;
            aSimulation.Simulate() ;

        } // else if cmd == 2
        else
            cout << "Unknown command.\n" ;

        cout << "(0)Exit\n(1)Sort file\n(2)Simulate(not yet)\n" ;
        cout << "Command: " ;
        cin >> cmd ;

    } // while

    return 0 ;

} // main()
