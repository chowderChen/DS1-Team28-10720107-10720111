// 10720111 陳少暉 10720107 陳丕中

#include<iostream>
#include<cstdio>
#include<vector>
#include<string>
#include<ctime>

using namespace std ;

struct Job {

    // 每個工作所帶有的資料
    int ID ;
    int arrival ;
    int duration ;
    int timeout ;

};

class sortQueue {

    struct QueueNode {
		int num ;
		QueueNode * next ;
	};

	QueueNode * backPtr ;
	QueueNode * frontPtr ;

public :
	
	Queue() ;
	bool IsEmpty() ;
	void EnQueue( int newNum ) ;
	void DeQueue() ;
	void DeQueue( int getNum ) ;
	void GetFront( int getNum ) ;
	

		
 // destructor

	bool Queue::IsEmpty() { 
		if ( frontPtr == NULL )
		    return true ;
		else if ( backPtr == NULL )
		    return true ;
	    else
	        return false ;
	} // isEmpty()

	void Queue::EnQueue ( int newNum ) { // enQueue() 新增 
	   // 將東西放入queue
		QueueNode * newPtr = new QueueNode ;
		newPtr->num = newNum ;
		newPtr->next = NULL ;

		if ( isEmpyt() )
		    frontPtr = newPtr ;
		else
		    backPtr->next = newPtr ;

	    backPtr = newPtr ;
	} // enQueue()

	void Queue::DeQueue () { // deQueue 移除 
	    // 將東西拿出queue
	
		if ( isEmpty() ) {
			printf( "is Empty!") ;
		} // if
		else {

		    QueueNode * tempPtr = frontPtr ;
		    if ( frontPtr == backPtr ) {
		    	frontPtr = NULL ;
		    	backPtr = NULL ;
		    } // if
		    else {
		    	frontPtr = frontPtr->next ;
		    } // else

		    tempPtr->next = NULL ;
	    	delete tempPtr ;
	    } // else
	} //deQueue()

	void Queue::GetFront ( int getNum ) { // getFront() 擷取 
	    // 看queue最前面是什麼
	
		if ( isEmpty() )
		    printf("is Empty!!") ;

	    else
	        getNum = front->num ;
	} // getFront()
	
	void Queue::DeQueue( int getNum ) { // deQueue() 擷取後刪除
	    if( isEmpty() ) {
	    	printf("is Empty!") ;
		} // if
		else {
			getNum = frontPtr->num ;
			deQueue() ;
		} // else
		
	} // 擷取後刪除 
	

};
class JobList {
    // 存放工作的清單

    vector<Job> aList ;


public:

    void Sort() ;
    bool Load() ;

}; // class JobList

void JobList::Sort(){
    // 用shell sort將其變為從小到大排序
    for ( int gap = aList.size()/2 ; gap > 0 ; gap = gap / 2 )
        for ( int i = gap ; i < aList.size() ; i++ ) {
            Job tempJob = aList.at( i ) ;
            int j = -1 ;
            for ( j = i ; j >= gap && tempJob.ID < aList.at( j - gap ).ID ; j = j - gap )
                aList.at( j ) = aList.at( j -  gap ) ;

            aList.at(j) = tempJob ;

        } // for


} // Sort

bool JobList::Load( string fileName ) {
    // 讀檔
    FILE *infile = NULL ;
    bool success = false ;

    fileName = "input" + fileName + ".txt" ;
    infile = fopen(fileName.c_str(), "r") ;

	if ( infile == NULL )
		;
	else{

        char temp ;

        while ( fscanf( infile, "%c", &temp ) != EOF && temp != '\n' )
            ;

        Job aJob ;
        while ( fscanf( infile, "%d %d %d %d", &aJob.ID, &aJob.arrival, &aJob.duration, &aJob.timeout ) != EOF )
            aList.push_back( aJob ) ;

        success = true ;
        fclose( infile ) ;

	} // else

	return success ;

} // Load

int main(){

    JobList aList ;
    string fileName ;
    cout << "file name:" ;
    cin >> fileName ;
    aList.Load( fileName ) ;
    aList.Sort() ;

    return 0 ;

} // main()
